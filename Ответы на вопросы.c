// ответы на вопросы

/* Windows HOOK. Назначение и особенности использования.
// Что такое?
Windows HOOK любой код, который перехватывает или подменяет вызовы, сообщения и события производимые системами или приложениями
Техника использования HOOK называется перехват (hooking) 
// Зачем?
Перехват может использоваться для отладки или расширения функционала различных функций (KEYLOGGER), так же перхват используется во вредоносном ПО
В пример HOOK можно назвать появление выпадающего меню при нажатии на рабочий стол

За установку HOOK отвечает функция SetWindowsHookEx 
При помощи GetMessageW получаем список входящих системных событий (также данная функция заполняет структуру MSG)
*/

/*Актуальность синхронизации потоков при параллельной обработке данных
В случае когда два или более потоков пытаются получить одновременный доступ к какому-либо общему ресурсу (Например К данным в оперативной памяти),
Поведение программа может быть неверным. Значение может быть записано раньше времени или прочитана раньше времени.
Соответсвенно для нормальной работы приложения с ресурсами необходимо синхронизировать действия этих потоков
Синхронную  работу с ресурсами можно обеспечить при помощи критической секции

Критическая секция объявляется следующим образом:
-Создаётся Переменная соответствующего типа CRITICAL_SECTION section = { 0 }; 
-До начала выполнения потока необходимо инициализировать критическую секцию с помощью соответствующей функции: InitializeCriticalSection(&section);
-Участок кода,  да который контролируется критической секцией должен находиться между инструкциями EnterCriticalSection(&section); и LeaveCriticalSection(&section);
-После окончание работы потоков можно освободить критическую секцию с помощью функции DeleteCriticalSection(&section);
*/ 

/*Библиотеки DLL. Назначение и использование DLL-библиотек
DLL библиотека представляет из себя скомпилированное хранилище готовых функций, 
которые затем могут быть использованны при разработки программ.
В основном они используются для того чтобы эффективно разместить функции, которые могут использоваться в большом кол-ве в различных программ
Также DLL экономит память (из-за того что не нужно писать одинаковые функции несколько раз в разных программах)

Для этого используются три основных шага:
-Подключается DLL. (Создается дескриптор данной библиотеки)
-Импортируется функция из этой библиотеки
-Освобождается память под дескриптор (Отключается библиотека)

Для импорта функции необходимо сначала создать указатель на функцию с сигнатурой.
Далее необходимо иициализировать данную функцию. (присвоив ей значение функции из DLL)

Есть ещё один прикол связанный с импортом библиотеки из WINapi в C# (в принципе всё тоже самое) для этого нужно
Объявить прототип функции. Для этого нужно:
-подключить пространство имён: using System.Runtime.InteropServices;
-Использовать атрибут [DllImport]. У этого атрибута есть несколько параметров, Они передаются внутри скобок ( как у метода)
-Нужно Правильно указать соглашение о вызовах в атрибуте [DllImport] импорт.  Дело в том что по умолчанию считается __stdcall, А у нас в библиотеке __cdecl
-Далее описать сигнатуру вызываемой функции dll. Только нужно заменить типы данных ( те,  те которые используются в Windows, на те, как которые Используются в языке си #)
*/

/* Именованные каналы. Назначение и использование
Каналы - область виртуального пространства,  которое может быть использовано для совместного доступа различными процессами.

Именованные каналы не существуют постоянно и не могут быть созданы как специальные файлы в произвольной доступной для записи файловой системе,
но имеют временные имена (освобождаемые после закрытия последней ссылки на них), которые выделяются в корне файловой системы именованных каналов 
(англ. named pipe filesystem, NPFS) и монтируются по специальному пути «\.\pipe» (то есть у канала под названием «foo» полное имя будет «\.\pipe\foo»). 
Анонимные каналы, использующиеся в конвейерах, — это на самом деле именованные каналы со случайным именем.

Процесс который создаёт канал это - сервер,  а процессы,  которые подключаются к каналу -  клиенты
Одно из разновидностей каналов является именнованый.
Дескриптор выступает в качестве идентификатора определённого ресурса
В качестве идентификатора именованного канала используются дискриптор и имя в виде строки 

Перед работой с каналами нужно чтобы "сервер" создал (CreateNamedPipe ) его и 
была проведена проверка на поодключения клиентов (ConnectNamedPipe) со стороны сервера.
*/

/*Линейный односвязный список. Особенности создания и примеры использования
Представляет из себя набор структур содержащих в себе какие либо прикладные значения и так же указатель на следующий эл. списка памяти.
Соответсвенно изменение указателя у одного эл. списка приведёт к изменению последовательности элементов в списке в целом.
Такие списки необходимы для рапределённого  хранение значений в памяти
Т.к. массивы распологают все значения в памяти последовательно, друг за другом в памяти может не всегда имется нужное кол-во неприрывно свободного пространства
Линейный однос. список решает эту проблему.

Поскольку ЛОС хранит только значение след. эл. последовательности, то значение его головного эл. нужно запоминать отдельно
У полседнего э. списка указатель на след. эл. = NULL
*/

/* Массив как тип данных. Особенности использования массивов при разработке программ на си
Данные - это информация, котрую можно приминить.
Тип данных - это то как данные подразделяются.
Одним из типов данных является массив. Фактически массив является указателем на последовательность элементов определенного типа.
Имя массива является указателем на первый элемент.
А объём памяти равен суммарному объему Всех элементов с учетом их типа.

С массивами в СИ можно работать несколькими способами:как с указателями и встроинным в язык методом работы с массивом
Встроенным методом работать проще потомучто при помощи него можно обращаться к любому эл. массива по порядковому номеру.
В таком случае не нужно запоминать голову массива. Однако у такого способа есть недостаток - отсутствует возможность создать массив с динамической размерностью.
Эту проблему решает метод работы с массивом как с указателем. В данном случае на нужное кол-во элементов нужно выделить память (и после использования не забыть её очистить).
*/

/*Многопоточный режим работы компьютера. преимущества использования многопоточности
Поток — это по сути последовательность инструкций (поток в оличие от процесса выполняется на процессоре и использует ресурсы процесса (не знаю зачем это, но живи с этим)).
Многопоточность - состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно»,
то есть без предписанного порядка во времени.

Есть два вида многопоточности: временная (когда в один момент времени выполняется только один поток) и одновременная
Т.е. однопроцессорные карлики только эмулируют многопоточность, а по факту там очередь. 
Тогда как многопроцессорные звери выполняют несколько действий одновременно из-зи того что очереди 2 или более.

Приемущества: 
-экономия времени за счёт распараллеливания задач; 
-использование птоками единого адресного пространства для передачи данных между собой (внутри одного процесса);
-разделение ответсвенности за разные задачи между потоками одной программы (при ошмбки не надо перекомпилировать программу заново);
-удобство для рядового пользователя

Подробнее:
https://habr.com/ru/company/otus/blog/549814/
*/

/* Особенности использования строкового типа данных. Массивы строк
Ну хз, тоже самое что и про массивы (сказанно выше)
Можно добавить что массив состои из однобайтных символов типа char и при инициализации строки можно написать L, т.е. UNICODE (изначально находится в ASCII)
И да в языке СИ нет отдельного строкового типа данных
*/


/*Особенности настройки проекта и использования синтаксиса языка программирования при написании DLL-файла
Настройка:
-Свойство конфигурации / Набор символов / использовать Юникод
-С\С++/Предварительно откомпилированные заголовки / «Не использовать предварительно откомпилированные заголовки
-С\С++/Дополнительно/Компилировать как код С
-Компоновщик/Все параметры/ выставить подсистему Windows
Настроука для DLL:
Всё также кроме того что нужно Компилировать как С++ и во вкладке общие поставить что это Приложение dll

Точка входа у библиотеки своя и выглядит так:
BOOL WINAPI DllMain(HINSTANCE hlnstDll, DWORD dwReason, LPVOID IpReserved)
{
	BOOL bAllWentWell = TRUE;
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	if (bAllWentWell)
		return TRUE;
	else
		return FALSE;
}

Всем экспортируемые из DLL функции. Должны иметь специальные соглашения о вызовах _cdecl.
Также функции нужно пометить с помощью оператора: __declspec(dllimport) - для импортируемых и __declspec(dllexport)  - для экспортируемых функций.
Описываются сие приколы в прототипе функции
*/

/*Особенности разработки программ в WinAPI
API - описание способов, которыми одна компьютерная программа может взаимодействовать с другой программой.
WINapi - это такой интерфейс, который предоставляет Windows для выполнения определённых системных задач сторонними программами (т.е. видовс предоставляет нам инструменты для наших нужд).

Для работы с этими функциями нужно подключить библиотеку Windows.h
Далее появляются новые типы данных:
-Тип BYTE обозначает 8-разрядное беззнаковое символьное значение.
-Тип WORD — 16-разрядное беззнаковое короткое целое.
-Тип DWORD — беззнаковое длинное целое.
-Тип UINT — беззнаковое 32-разрядное целое.
-Тип LONG эквивалентен типу long.
-Тип BOOL обозначает целое и используется, когда значение может быть либо истинным, либо ложным.
-Тип LPSTR определяет указатель на строку.
-Тип LPCSTR определяет константный (const) указатель на строку.
-Тип HANDLE обозначает 32-разрядное целое, используемое в качестве дескриптора.
Дескриптор выступает в качестве идентификатора определённого ресурса
Также нужно использовать спец функцию для запуска приложений Windows:
int WINAPI WinMain(HINSTANCE hlnstance. // дескриптор, присваиваемый запущенному приложению
HINSTANCE hPrevInstance, // для совместимости с winl6. в Win32 не используется
LPSTR lpCmdLine. // указатель на командною строку, если приложение так запущено
int nCmdShow); // значение, которое может быть передано в функцию Show Window ()

После выполнение данного кода создатья процесс, который не имеет интерфейса. (для вывода и ввода информации используются файлы, канлы и т.д.)
и да надо настроить сие прикол


*/

